#include "Game.h"

#include <core/Entity.h>
#include <core/PositionComponent.h>
#include <core/RotationComponent.h>

#include "InputComponent.h"
#include "PhysicsComponent.h"
#include "../network/GameServer.h"
#include "../network/ServerEventHandlerLookup.h"

#define PI 3.14159265359
#define deg2rad(d) (PI / 180.0 * d)

Game::Game(ConfigSettings *config)
    : config(config),
    playerFactory(&entityManager),
	bombFactory(&entityManager),
    eventHandlerLookup(this),
    server(config, eventHandlerLookup) {

    broadphase = new btDbvtBroadphase();
    collisionConfiguration = new btDefaultCollisionConfiguration();
    dispatcher = new btCollisionDispatcher(collisionConfiguration);
    solver = new btSequentialImpulseConstraintSolver;

    world = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);

    world->setGravity(btVector3(0, 0, -4.0)); // TODO: Extract gravity constant
}

Game::~Game() {
    delete broadphase;
    delete collisionConfiguration;
    delete dispatcher;
    delete solver;
}

void Game::loadMap() {
    // TODO: Handle memory leak
    btCollisionShape *groundShape = new btStaticPlaneShape(btVector3(0, 0, 1), 1);
    btDefaultMotionState *groundMotionState = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), btVector3(0, 0, -1)));

    btRigidBody::btRigidBodyConstructionInfo groundRigidBodyCI(0, groundMotionState, groundShape, btVector3(0, 0, 0));
    btRigidBody *groundRigidBody = new btRigidBody(groundRigidBodyCI);

    world->addRigidBody(groundRigidBody);
}

void Game::addPhysicsEntity(Entity *entity) {
    PhysicsComponent *physicsCom = entity->getComponent<PhysicsComponent>();

    if (physicsCom != nullptr) {
        world->addRigidBody(physicsCom->getRigidBody());
    }
}

void Game::update(float timeStep) {

	//HERE is where the client first connect to server,
    //we want to have client load the gameworld first,
    //then create the player, and send the spawn player event to client
	if (server.acceptNewClient(entityManager.getNextId())) {

		//now we create a new player
        Entity *player = playerFactory.createPlayer(0, -5, 5);
        players.push_back(player);
        addPhysicsEntity(player);

		//notify client, a player spawn occurs
		//server->sendPlayerSpawnEvent(player, players);
		server.sendEntitySpawnEvent(player);
		server.sendAllEntitiesSpawnEvent(player,entityManager.getEntityList());
        //first have the client first preload the information about the world
        server.sendGameStatePackets(this);
    }

    server.receive();

    // Handle game logic here

    // TODO: Extract this into MovementSystem class.
    for (Entity *entity : entityManager.getEntityList()) {
        InputComponent *inputCom = entity->getComponent<InputComponent>();
		RotationComponent *rotCom = entity->getComponent<RotationComponent>();
        PhysicsComponent *physCom = entity->getComponent<PhysicsComponent>();

        if (inputCom == nullptr || physCom == nullptr) {
            continue;
        }

        btRigidBody *rigidBody = physCom->getRigidBody();
        btVector3 velocity = rigidBody->getLinearVelocity();

		// TODO: currently, forward & backward event will override 
		// the front and right velocity generated by the physics.
		// Only velocity on the z axis is taken from the physics calc

		// forward & backward & left & right w.r.t orientation
		btQuaternion rot0;
		btQuaternion rot1;
		btScalar yaw = rotCom->getYaw();
		btScalar pitch = rotCom->getPitch();
		rot0.setRotation(btVector3(0, 0, 1), deg2rad(-yaw));
		rot1.setRotation(btVector3(1, 0, 0), deg2rad(pitch));
		btQuaternion rot = rot0 * rot1; // order different from osg::Quat
		btVector3 viewDir = quatRotate(rot, btVector3(0, 1, 0));

		// construct local coordinate system
		btVector3 front = viewDir;
		btVector3 right = front.cross(btVector3(0, 0, 1));
		right.normalize();
		// do not calculate head vector, since gravity is always neg z 

		btVector3 localVelocity(0.0, 0.0, 0.0);

		// Define y to be front speed, x to be right speed
        if (inputCom->isMovingForward()) {
			localVelocity.setY(1);
        } else if (inputCom->isMovingBackward()) {
			localVelocity.setY(-1);
        } else {
			localVelocity.setY(0);
        }

        if (inputCom->isMovingLeft()) {
			localVelocity.setX(-1);
        } else if (inputCom->isMovingRight()) {
			localVelocity.setX(1);
        } else {
			localVelocity.setX(0);
        }

		btVector3 worldVelocity(right * localVelocity.getX() + front * localVelocity.getY());
		worldVelocity.setZ(velocity.getZ());

		rigidBody->setLinearVelocity(worldVelocity);
    }

	for (Entity *entity : entityManager.getEntityList()) {
		entity->getComponent<PhysicsComponent>()->getRigidBody()->activate(true);
    }

    world->stepSimulation(timeStep);
    
	for (Entity *entity : entityManager.getEntityList()) {
		PositionComponent *positionCom = entity->getComponent<PositionComponent>();
		PhysicsComponent *physicsCom = entity->getComponent<PhysicsComponent>();

        const btVector3 &position = physicsCom->getRigidBody()->getWorldTransform().getOrigin();
        positionCom->setPosition(position.getX(), position.getY(), position.getZ());
    }

    server.sendGameStatePackets(this);
}

const EntityManager &Game::getEntityManager() const {
    return entityManager;
}

const PlayerFactory &Game::getPlayerFactory() const {
    return playerFactory;
}

const BombFactory &Game::getBombFactory() const {
    return bombFactory;
}

const GameServer &Game::getGameServer() const {
    return server;
}
